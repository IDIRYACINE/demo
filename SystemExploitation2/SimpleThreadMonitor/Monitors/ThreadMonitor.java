package SystemExploitation2.SimpleThreadMonitor;

import java.util.concurrent.Semaphore;

import SystemExploitation2.SimpleThreadMonitor.Conditions.ICondition;
import SystemExploitation2.SimpleThreadMonitor.Threads.ISimpleThread;
import SystemExploitation2.SimpleThreadMonitor.Threads.ThreadA;
import SystemExploitation2.SimpleThreadMonitor.Threads.ThreadB;

public class ThreadMonitor implements IThreadMonitor{
    private static  ThreadMonitor instance;
    private ISimpleThread[] threadsA;
    private ISimpleThread[] threadsB;
    private static final int NUMBER_OF_ITERATIONS = 1000;
    private static int[] awaitingThreads = {0,0};
    private Semaphore mutex ;
    private boolean[] threadIsWokring = {false , false};
    private ICondition condition;

    
    private ThreadMonitor() {
        mutex = new Semaphore(1);
    }

    public static ThreadMonitor getInstance(){
        if(instance == null){
            instance = new ThreadMonitor();
        }
        return instance;
    }

    @Override
    public void createThreads(int threadsAcount , int threadsBcount){
        threadsA = new ISimpleThread[threadsAcount];
        for (int i = 0 ; i < threadsAcount ; i++){
            threadsA[i] = new ThreadA(NUMBER_OF_ITERATIONS, "na");
        }

        threadsB = new ISimpleThread[threadsBcount];
        for (int i = 0 ; i < threadsAcount ; i++){
            threadsB[i] = new ThreadB(NUMBER_OF_ITERATIONS, "nb");
        }
        
    }

    @Override
    public void startThreads(){
        int THREADS_COUNT = threadsA.length;
        for (int i = 0 ; i < THREADS_COUNT ; i++){
            threadsA[i].start();;
        }

        THREADS_COUNT = threadsB.length;
        for (int i = 0 ; i < THREADS_COUNT ; i++){
            threadsB[i].start();
        }

    }


    @Override
    public void acquireMutexPermissions(){
        try {
            mutex.acquire();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

    @Override
    public void releaseMutexPermissions(){
        mutex.release();
    }

    @Override
    public boolean getThreadStatus(int index){
        return threadIsWokring[index];
    }


    @Override
    public void setThreadStatus(int index,boolean status){
        threadIsWokring[index] = status;
    }
    
    @Override
    public void modifyAwaitingThreads(int Index , int value){
        awaitingThreads[Index] += value;
    }

    @Override
    public boolean isThelastThread(int index){
        return awaitingThreads[index] == 1;
    }

    @Override
    public void setCondition(ICondition condition){
        this.condition = condition;
    }

    @Override
    public boolean checkBworkCondition() {
        int valueB = threadsB[0].getInternalValue();
        int valueA = threadsA[0].getInternalValue();
        return  condition.bCondition(valueA, valueB);
    }

    @Override
    public boolean checkAworkCondition() {
        int valueB = threadsB[0].getInternalValue();
        int valueA = threadsA[0].getInternalValue();
        return condition.aCondition(valueA, valueB);
    }
    
}
